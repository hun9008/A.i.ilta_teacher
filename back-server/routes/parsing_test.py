import re

def parse_solution(solution):
    # Step이나 Answer, 정답이 포함된 패턴을 유연하게 매칭
    steps = re.split(r'(Step \d+:|Answer:|정답:)', solution)
    
    # 결과를 담을 리스트
    steps_array = []
    
    # 스텝이나 정답 키워드를 앞에 붙여서 저장
    current_step = ""
    for i in range(1, len(steps), 2):  # 홀수 인덱스가 키워드
        current_step = steps[i] + steps[i+1].strip()
        steps_array.append(current_step)
    
    return steps_array

# 디버깅을 위한 예제 문자열
solutions = [
    """이 문제를 해결하는 방법을 단계별로 설명하겠습니다. 문제는 정수의 소인수들의 합을 비교하고, 이들 중 가장 큰 합을 가진 수를 찾는 것입니다. 하지만 구체적인 숫자예시가 제시되지 않았으므로, 이해를 돕기 위해 예시를 들어 설명하겠습니다.

예를 들어, 다음과 같은 수가 있다고 가정합시다: 30, 45, 70.

Step 1: 각 수의 소인수분해를 합니다.
- 30 = 2 × 3 × 5, 소인수의 합 = 2 + 3 + 5 = 10
- 45 = 3 × 3 × 5, 소인수의 합 (중복 소인수 포함해서 계산) = 3 + 3 + 5 = 11
- 70 = 2 × 5 × 7, 소인수의 합 = 2 + 5 + 7 = 14

Step 2: 계산된 소인수의 합을 비교합니다.
- 30의 소인수의 합 = 10
- 45의 소인수의 합 = 11
- 70의 소인수의 합 = 14

위 예시에서 소인수의 합이 가장 큰 수는 70입니다.

정답: 만약 주어진 숫자들이 30, 45, 70이라면 모든 소인수의 합이 가장 큰 수는 70입니다. (정답: 70)

위의 문제 해결 방법은 주어진 숫자들에 대한 소인수 분해와 그 합을 계산하여 비교하는 절차를 따릅니다. 실제 문제에서는 다른 숫자들이 주어질 수 있으므로, 그 숫자들에 대해서 같은 방법으로 계산하면 됩니다.""",
    
    """이 수학 문제에서는 주어진 식 \(8 \times 2^5 \times 7 \times a\) 가 어떤 자연수의 제곱이 되도록 하는 가장 작은 자연수 \(a\)를 찾아야 합니다.

Step 1 : 주어진 식을 간소화합니다.

\(8 = 2^3\) 이므로,
\(8 \times 2^5 = 2^3 \times 2^5 = 2^8\)

이제 식은 \(2^8 \times 7 \times a\)로 나타낼 수 있습니다.

Step 2 : 식을 어떤 수의 제곱으로 만들기 위해, 모든 소인수의 지수가 짝수가 되도록 해야 합니다.

현재 \(2^8\)의 지수는 8(짝수)이며, \(7\)의 지수는 1(홀수)입니다.

Step 3 : \(7\)의 지수를 짝수로 만들기 위해 \(a\)에 \(7\)을 곱해야 합니다.

이 경우, \(a = 7\)이 되며, 식은 \(2^8 \times 7^2\)가 됩니다. \(7^2\)는 \(49\)이므로 타당합니다.

Step 4 : 결과를 검증합니다.

모든 소인수의 지수가 짝수가 되었으므로 \(2^8 \times 7^2\) 식은 어떤 자연수의 제곱입니다.
특히, \(2^8 \times 7^2 = (2^4 \times 7)^2 = (16 \times 7)^2 = 112^2\)이므로 이 식은 112의 제곱이 됩니다.

(정답: 7)"""
]

# 각 솔루션에 대해 단계별 파싱 수행
for solution in solutions:
    parsed_steps = parse_solution(solution)
    for p in parsed_steps:
        print("### parsing ###")
        print(p)
    print("Length of Parsed Steps:", len(parsed_steps))